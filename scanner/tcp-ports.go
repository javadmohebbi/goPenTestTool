package scanner

import (
	"fmt"
	"net"
	"sync"
	"time"

	"github.com/gookit/color"

	"github.com/javadmohebbi/goPenTestTool/utils/cidr"
	"github.com/javadmohebbi/goPenTestTool/utils/port"
)

// define custom type for IsOpen
type IsOpen bool

func (i IsOpen) String() string {
	if i {
		return "open"
	}
	return "close"
}

// This struct will be provided by user input
// to define the target he/she/... wants to scan tcp ports
type TCPScanner struct {

	// it MUST be in IP/mask (CIDR) format
	Target string `json:"target"`

	// If it set to true, the result includes only Open Ports
	JustOpenPorts bool `json:"justOpenPorts"`

	// if true, it will print logs to console
	Verbose bool `json:"verbose"`

	// Timeout for each Target int Second
	// default is 10 sec
	Timeout time.Duration `json:"timeOut"`

	// limit the nimber of max threads
	// default is 5,
	// max is 100
	MaxThreads int `json:"maxThreads"`

	// just for report to the console
	total   int64
	current int64

	totalOpened int64

	service port.Service
}

type Port int

// get port name
func (p Port) GetName(s *port.Service) string {
	return s.GetNameByNumber(int(p), "tcp")
}

// TCPScannerResponse will be used to return the scan result
type TCPScannerResponse struct {
	// IP address
	IP string `json:"ip"`

	// Port
	Port Port `json:"port"`

	// If set to true, it means the port is open
	IsOpen IsOpen `json:"isOpen"`

	// the program fill try to set the Human Friendly Name for the Port number
	PortName string `json:"portName"`
}

// Scan func scans the Target & returns an array of TCPScannerResponse struct
// in case of error, it will return no result
func (t *TCPScanner) Scan() ([]TCPScannerResponse, error) {

	ips, err := cidr.ParseIPv4Array(t.Target)
	if err != nil {
		return []TCPScannerResponse{}, err
	}

	// set the timeout interval
	if t.Timeout <= 0 || t.Timeout >= 60 {
		t.Timeout = 10
	}

	// set the job max limit
	if t.MaxThreads <= 0 || t.MaxThreads > 100 {
		t.MaxThreads = 5
	}

	// init services
	t.service.Init()

	t.total = int64(len(ips) * 65535)
	t.current = int64(0)

	// define concurrent go routins
	concurrentGoroutines := make(chan struct{}, t.MaxThreads)

	var wg sync.WaitGroup

	var resps []TCPScannerResponse

	// loop through IP addresses
	for j, ip := range ips {

		// loop through Ports
		for p := Port(0); p <= 65535; p++ {

			resp := TCPScannerResponse{
				IP: ip, Port: p, PortName: p.GetName(&t.service), IsOpen: false,
			}

			// call scan method with goroutines
			// concurrentGoroutines <- struct{}{}

			wg.Add(1)
			go func(j int, resp *TCPScannerResponse) {
				defer wg.Done()

				// increase the current
				t.current += 1

				concurrentGoroutines <- struct{}{}

				// scan
				t.scan(resp.IP, resp.Port, resp)

				resps = append(resps, *resp)

			}(j, &resp)

			wg.Wait()
			<-concurrentGoroutines
		}
	}
	close(concurrentGoroutines)

	return resps, nil
}

// scan checks every IPs:ports & dial & find if the provided IP:PORT is open or not
func (t *TCPScanner) scan(ip string, port Port, resp *TCPScannerResponse) {

	// try to connect to provided TCP IP:Port in the prodvided Timeout
	_, err := net.DialTimeout("tcp", fmt.Sprintf("%v:%d", ip, port), time.Second*t.Timeout)

	// check if has error
	if err == nil {
		resp.IsOpen = true
		t.totalOpened += 1
	} else {
		resp.IsOpen = false
	}

	if t.Verbose {
		fmt.Printf("[Verbose] port '%v' on host '%v' is '%v'\n", port, ip, resp.IsOpen)
		if resp.IsOpen {
			fmt.Printf("[Verbose] port '%v' on host '%v' is '%v'\n", port, ip, resp.IsOpen)
		}
	} else {
		t.printInfo()
	}

}

// print info to the console
func (t *TCPScanner) printInfo() {
	fmt.Print("\033[s") // save the cursor position
	// fmt.Printf("\033[34m%v%% is done! (%v out of %v) \n", (100 * t.current / t.total), t.current, t.total)
	// fmt.Printf("\t\033[34mTotal opened port(s): %v \n", t.totalOpened)
	color.Cyan.Printf("%v%% is done! (%v out of %v) \n", (100 * t.current / t.total), t.current, t.total)
	if t.totalOpened > 0 {
		color.Green.Printf("\tTotal opened port(s): %v \n", t.totalOpened)
	} else {
		color.Warn.Printf("\tTotal opened port(s): %v \n", t.totalOpened)
	}

	fmt.Print("\033[A") // move the cursor up
	fmt.Print("\033[A") // move the cursor up
}
