package scanner

import (
	"context"
	"fmt"
	"log"
	"net"
	"os"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/cheggaaa/pb/v3"

	"github.com/javadmohebbi/goPenTestTool/utils/reports"
	"github.com/javadmohebbi/goPenTestTool/utils/ulimit"
	"golang.org/x/sync/semaphore"

	"github.com/javadmohebbi/goPenTestTool/utils/target"
	"github.com/olekukonko/tablewriter"

	"github.com/gookit/color"

	"github.com/javadmohebbi/goPenTestTool/utils/cidr"
	"github.com/javadmohebbi/goPenTestTool/utils/port"
)

// define custom type for IsOpen
type IsOpen bool

// if IsOpen is true it will return open, and for false will return close
func (i IsOpen) String() string {
	if i {
		return "open"
	}
	return "close"
}

// This struct will be provided by user input
// to define the target he/she/... wants to scan tcp ports
type TCPScanner struct {

	// it MUST be in IP/mask (CIDR) format
	Target string `json:"target"`

	// TargetPort
	TargetPorts string `json:"targetPorts"`

	// FileReportPath for reports
	OutputPath string `json:"output"`

	// If it set to true, the result includes only Open Ports
	JustOpenPorts bool `json:"justOpenPorts"`

	// if true, it will print logs to console
	Verbose bool `json:"verbose"`

	// Timeout for each Target int Second
	// default is 10 sec
	Timeout time.Duration `json:"timeOut"`

	// limit the nimber of max threads
	// default is 5,
	// max is 100
	MaxThreads int `json:"maxThreads"`

	lock *semaphore.Weighted
	wg   sync.WaitGroup

	target     target.Target
	targetType target.TargetType

	portsToScan []int

	// just for report to the console
	total   int64
	current int64

	totalOpened int64

	service port.Service

	needReport bool
	report     *reports.Reports

	printed []int

	barInited bool
	bar       *pb.ProgressBar

	result *[]TCPScannerResponse
}

// Custom int type for Port
type Port int

// get port name
func (p Port) GetName(s *port.Service) string {
	return s.GetNameByNumber(int(p), "tcp")
}

// TCPScannerResponse will be used to return the scan result
type TCPScannerResponse struct {
	// IP address
	IP string `json:"ip"`

	// Port
	Port Port `json:"port"`

	// If set to true, it means the port is open
	IsOpen IsOpen `json:"isOpen"`

	// the program fill try to set the Human Friendly Name for the Port number
	PortName string `json:"portName"`
}

// Scan func scans the Target & returns an array of TCPScannerResponse struct
// in case of error, it will return no result
func (t *TCPScanner) Scan(result *[]TCPScannerResponse) error {

	// this is just to wait for results
	defer time.Sleep(1 * time.Second)

	// set the target
	t.target = target.Target(t.Target)

	// type of target
	t.targetType = t.target.GetType()

	// get type of ports
	ports := target.TargetPorts(t.TargetPorts)

	// extract []int of needed ports to scan
	t.portsToScan = ports.GetPorts()

	// print target to console
	fmt.Printf("Target=%s ==> %v\n", t.targetType, t.target)

	// list of hosts to scan
	hostsToScan := []string{}

	// variable for errors
	var err error

	// switch between type of target
	// and extract hostsToScan
	switch t.targetType {
	case target.TARGET_SINGLE_HOST:
		hostsToScan = []string{t.Target}
	case target.TARGET_SINGLE_IPv4:
		hostsToScan = []string{t.Target}
	case target.TARGET_SINGLE_IPv6:
		hostsToScan = []string{t.Target}
	case target.TARGET_CIDR_v4:
		hostsToScan, err = cidr.ParseIPv4Array(t.Target)
	case target.TAREGT_MULTIPLE_IP:
		for _, h := range strings.Split(t.Target, ",") {
			hostsToScan = append(hostsToScan, h)
		}
	default:
		panic("NO VALID TARGET HAVE FOUND!")
	}

	// set report path if needed
	if t.OutputPath == "" {
		t.needReport = false
	} else {
		// create new report
		// if has err, needReport will be false
		// and writing to a file will be ommited!
		rpt, err := reports.New(t.OutputPath)
		if err != nil {
			// if has error, we dont provide any RPT
			if t.Verbose {
				color.Red.Printf("[ERROR] Can not write to the requested RPT due to error '%v'", err.Error())
			}
			t.needReport = false
		} else {
			// if need RPT
			t.needReport = true
			t.report = rpt
		}
	}

	// extract hosts errors
	if err != nil {
		return err
	}

	// set the timeout interval
	// if timeout is greater than 60s or less than 1s it will set to 3s
	if t.Timeout <= 1 || t.Timeout >= 60 {
		t.Timeout = 3
	}

	// set the job max limit
	// set concurrent jobs
	if t.MaxThreads <= 0 || t.MaxThreads > 8192 {
		t.MaxThreads = 5
	}

	// init services
	// it will read from /etc/services
	t.service.Init()

	// get total number of scans
	t.total = int64(len(hostsToScan) * (len(t.portsToScan)))

	// finish pb if needed
	defer t.finishProgressBar()

	// this variable use to set the currently scanned "host:port"s
	t.current = int64(0)

	// if total is less than maxThreads
	// it will set it to the lower value which is t.total
	if t.total < int64(t.MaxThreads) {
		t.MaxThreads = int(t.total)
	}

	// get ulimit & check it with maxThreads
	// using ulimit -n
	ulimit := ulimit.Get()
	if ulimit != -1 {
		if ulimit < int64(t.MaxThreads) {
			t.MaxThreads = int(ulimit)
		}
	} else {
		ulimit = int64(t.MaxThreads)
	}

	// Weighted provides a way to bound concurrent access to a resource. The callers can request access with a given weight.
	t.lock = semaphore.NewWeighted(t.total)

	// set result
	t.result = result

	// loop through hosts which we want to scan
	for _, host := range hostsToScan {
		t.scans(host)
	}

	return nil
}

// gracefully stop when CTRL+C pressed
func (t *TCPScanner) ForceStop() {
	if !t.Verbose {
		t.PrintTable()
	}

	t.wg.Done()
	if t.needReport {
		t.report.Close()
	}
}

// scans runs every scan for each port for a host
func (t *TCPScanner) scans(ip string) {

	if !t.Verbose {
		t.printProgressBar()
	}
	// loop through all neede ports
	for _, pt := range t.portsToScan {

		// convert int to Port
		p := Port(pt)

		ctx, cb := context.WithTimeout(context.Background(), (1+t.Timeout)*time.Second)
		defer cb()

		defer t.wg.Wait()
		t.lock.Acquire(ctx, 1)
		t.wg.Add(1)

		go func() {
			defer t.lock.Release(1)
			defer t.wg.Done()

			// create an instance of TCPResponse
			// it will pass to t.scan as refrence
			resp := TCPScannerResponse{
				IP: ip, Port: p, PortName: p.GetName(&t.service), IsOpen: false,
			}

			// scan single host:port
			t.scan(resp.IP, resp.Port, &resp)
		}()

	}
}

// scan checks every hostsToScan:ports & dial & find if the provided IP:PORT is open or not
func (t *TCPScanner) scan(ip string, port Port, resp *TCPScannerResponse) {

	// try to connect to provided TCP IP:Port in the prodvided Timeout
	_, err := net.DialTimeout("tcp", fmt.Sprintf("%v:%d", ip, port), time.Second*t.Timeout)

	// check if has error
	if err == nil {
		// successfully dialed the tcp HOST:PORT
		// So, it will set isopen to TRUE
		resp.IsOpen = true
		// increase totalOpened variable
		t.totalOpened += 1
	} else {
		// if error is because of soft ulimit (ulimit -n)
		// retry in 3 seconds and let user know
		// if verbose is provided
		if strings.Contains(err.Error(), "too many open files") {
			if t.Verbose {
				log.Printf("[ERROR] %v, retry in 1 second!", err)
			}
			time.Sleep(time.Second * 1)
			t.scan(ip, port, resp)
			return
		} else {
			// otherwise, it will consider it as close port
			resp.IsOpen = false
		}
	}

	*t.result = append(*t.result, TCPScannerResponse{
		IP: ip, Port: port, IsOpen: resp.IsOpen, PortName: port.GetName(&t.service),
	})

	// increase the current
	t.current += 1

	// prepare line for writing CSV file
	csvLine := t.lineCsv(ip, port.GetName(&t.service), port, resp.IsOpen)

	// check if verbose active, provide more info for user
	// if t.Verbose {
	// 	fmt.Printf("[Verbose] port '%v' on host '%v' is '%v'\n", port, ip, resp.IsOpen)
	// }

	go func() {
		if t.JustOpenPorts {
			// if port is open
			if resp.IsOpen {
				// if needReport is set, write report
				if t.needReport {
					_, _ = t.report.WriteLine(csvLine)
				}
			}
		} else {
			// if needReport is set, write report
			if t.needReport {
				_, _ = t.report.WriteLine(csvLine)
			}
		}
	}()

	// // when verbose is disable info will be printed to console
	// if t.Verbose {
	// 	// print info to console
	// 	t.printInfo()
	// } else {
	// 	t.printProgressBar()
	// }

	if !t.Verbose {
		t.updateProgressBar()
	}

}

// lineCsv will prepare a CSV comma delimited line for writing reports
// target,port,portname,status
func (t *TCPScanner) lineCsv(target, portName string, port Port, status IsOpen) string {
	return fmt.Sprintf("%s,%d,%v,%s", target, port, portName, status)
}

// print info to the console
func (t *TCPScanner) printInfo() {
	percent := (100 * t.current / t.total)

	ch := false

	if percent%5 == 0 {
		if len(t.printed) == 0 {
			t.printed = append(t.printed, int(percent))
		} else {
			for _, p := range t.printed {
				if p == int(percent) {
					ch = true
				}
			}
			if !ch {
				t.printed = append(t.printed, int(percent))
			}
		}

		if !ch {
			color.Cyan.Printf("%v%% is done! (%v out of %v total ports) \n", percent, t.current, t.total)
			if t.totalOpened > 0 {
				color.Green.Printf("\tTotal opened port(s): %v \n", t.totalOpened)
			} else {
				color.Warn.Printf("\tTotal opened port(s): %v \n", t.totalOpened)
			}
		}
	}

}

// finish progress
func (t *TCPScanner) finishProgressBar() {
	if t.barInited {
		t.bar.Finish()
	}
}

// show progress bar
func (t *TCPScanner) printProgressBar() {
	if !t.barInited {
		tmpl := `{{ string . "info" | yellow }} {{ bar . "" "-" (cycle . "↖" "↗" "↘" "↙" ) "." ">"}} {{string . "open" | green}} {{string . "closed" | red}} | {{percent . | rndcolor }}`
		t.bar = pb.ProgressBarTemplate(tmpl).Start64(t.total)
		t.bar.Set("open", fmt.Sprintf("Opened (%v)", t.totalOpened)).
			Set("closed", fmt.Sprintf("Closed (%v)", t.total-t.totalOpened)).
			Set("info", fmt.Sprintf("Total (%v)", t.total))

		t.bar.SetCurrent(0)

		t.barInited = true
		return
	}

}

// update progress bar
func (t *TCPScanner) updateProgressBar() {
	if !t.Verbose {
		t.bar.Set("open", fmt.Sprintf("Opened (%v)", t.totalOpened)).
			Set("closed", fmt.Sprintf("Closed (%v)", t.total-t.totalOpened)).
			Set("info", fmt.Sprintf("Total (%v)", t.total))

		t.bar.SetCurrent(t.current)
	}
}

// printTable will print output to the table
func (t *TCPScanner) PrintTable() {

	// convert struct for better result
	var tbl [][]string
	for _, r := range *t.result {
		if !t.JustOpenPorts {
			tbl = append(tbl,
				[]string{
					r.IP, strconv.Itoa(int(r.Port)), r.PortName, r.IsOpen.String(),
				},
			)
		} else {
			if r.IsOpen == true || t.Verbose {
				tbl = append(tbl,
					[]string{
						r.IP, strconv.Itoa(int(r.Port)), r.PortName, r.IsOpen.String(),
					},
				)
			}
		}

	}

	// just to move curser down a bit
	fmt.Printf("\n")

	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"IP", "PORT", "PORT NAME", "STATUS"})
	table.SetBorder(true)
	table.AppendBulk(tbl)
	table.Render()

}
