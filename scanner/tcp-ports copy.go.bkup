package scanner

import (
	"fmt"
	"log"
	"net"
	"os"
	"os/signal"
	"strconv"
	"strings"
	"sync"
	"syscall"
	"time"

	"github.com/javadmohebbi/goPenTestTool/utils/reports"

	"github.com/javadmohebbi/goPenTestTool/utils/target"
	"github.com/olekukonko/tablewriter"

	"github.com/gookit/color"

	"github.com/javadmohebbi/goPenTestTool/utils/cidr"
	"github.com/javadmohebbi/goPenTestTool/utils/port"
)

// define custom type for IsOpen
type IsOpen bool

func (i IsOpen) String() string {
	if i {
		return "open"
	}
	return "close"
}

// This struct will be provided by user input
// to define the target he/she/... wants to scan tcp ports
type TCPScanner struct {

	// it MUST be in IP/mask (CIDR) format
	Target string `json:"target"`

	// TargetPort
	TargetPorts string `json:"targetPorts"`

	// FileReportPath for reports
	OutputPath string `json:"output"`

	// If it set to true, the result includes only Open Ports
	JustOpenPorts bool `json:"justOpenPorts"`

	// if true, it will print logs to console
	Verbose bool `json:"verbose"`

	// Timeout for each Target int Second
	// default is 10 sec
	Timeout time.Duration `json:"timeOut"`

	// limit the nimber of max threads
	// default is 5,
	// max is 100
	MaxThreads int `json:"maxThreads"`

	target     target.Target
	targetType target.TargetType

	portsToScan []int

	// just for report to the console
	total   int64
	current int64

	totalOpened int64

	service port.Service

	needReport bool
	report     *reports.Reports
}

type Port int

// get port name
func (p Port) GetName(s *port.Service) string {
	return s.GetNameByNumber(int(p), "tcp")
}

// TCPScannerResponse will be used to return the scan result
type TCPScannerResponse struct {
	// IP address
	IP string `json:"ip"`

	// Port
	Port Port `json:"port"`

	// If set to true, it means the port is open
	IsOpen IsOpen `json:"isOpen"`

	// the program fill try to set the Human Friendly Name for the Port number
	PortName string `json:"portName"`
}

// Scan func scans the Target & returns an array of TCPScannerResponse struct
// in case of error, it will return no result
func (t *TCPScanner) Scan(resps *[]TCPScannerResponse) error {

	// set the target
	t.target = target.Target(t.Target)
	t.targetType = t.target.GetType()

	ports := target.TargetPorts(t.TargetPorts)
	t.portsToScan = ports.GetPorts()

	log.Printf("Target=%s ==> %v", t.targetType, t.target)

	ips := []string{}
	var err error

	switch t.targetType {
	case target.TARGET_SINGLE_HOST:
		ips = []string{t.Target}
	case target.TARGET_SINGLE_IPv4:
		ips = []string{t.Target}
	case target.TARGET_SINGLE_IPv6:
		ips = []string{t.Target}
	case target.TARGET_CIDR_v4:
		ips, err = cidr.ParseIPv4Array(t.Target)
	case target.TAREGT_MULTIPLE_IP:
		for _, h := range strings.Split(t.Target, ",") {
			ips = append(ips, h)
		}
	default:
		panic("NO VALID TARGET HAVE FOUND!")
	}

	// set report path if needed
	if t.OutputPath == "" {
		t.needReport = false
	} else {
		// create new report
		// if has err, needReport will be false
		// and writing to a file will be ommited!
		rpt, err := reports.New(t.OutputPath)
		if err != nil {
			t.needReport = false
		} else {
			t.needReport = true
			t.report = rpt
		}
	}

	// extract hosts errors
	if err != nil {
		return err
	}

	// set the timeout interval
	if t.Timeout <= 0 || t.Timeout >= 60 {
		t.Timeout = 10
	}

	// set the job max limit
	if t.MaxThreads <= 0 || t.MaxThreads > 1000 {
		t.MaxThreads = 5
	}
	// init services
	t.service.Init()

	t.total = int64(len(ips) * (len(t.portsToScan)))
	t.current = int64(0)

	// define concurrent go routins
	concurrentGoroutines := make(chan struct{}, t.MaxThreads)

	var wg sync.WaitGroup

	// capture CTRL+C
	c := make(chan os.Signal, 2)
	signal.Notify(c, os.Interrupt, syscall.SIGTERM)
	go func() {
		<-c
		fmt.Printf("\n\n\n Ctrl+C pressed in Terminal\n\n\n")
		t.stopAndReturn(concurrentGoroutines, *resps, &wg)
		os.Exit(0)
	}()

	// loop through IP addresses
	for j, ip := range ips {

		// loop through Ports
		for _, pt := range t.portsToScan {
			p := Port(pt)
			wg.Add(1)
			go func(j int) {
				defer wg.Done()

				resp := TCPScannerResponse{
					IP: ip, Port: p, PortName: p.GetName(&t.service), IsOpen: false,
				}

				// increase the current
				t.current += 1

				concurrentGoroutines <- struct{}{}

				// scan
				t.scan(resp.IP, resp.Port, &resp)

				*resps = append(*resps, resp)

			}(j)

			wg.Wait()
			<-concurrentGoroutines
		}
	}
	close(concurrentGoroutines)

	return nil
}

// gracefully stop when CTRL+C pressed
func (t *TCPScanner) stopAndReturn(c chan struct{}, resps []TCPScannerResponse, wg *sync.WaitGroup) {
	t.PrintTable(resps)
	wg.Done()
	close(c)
	if t.needReport {
		t.report.Close()
	}
}

// scan checks every IPs:ports & dial & find if the provided IP:PORT is open or not
func (t *TCPScanner) scan(ip string, port Port, resp *TCPScannerResponse) {

	// try to connect to provided TCP IP:Port in the prodvided Timeout
	_, err := net.DialTimeout("tcp", fmt.Sprintf("%v:%d", ip, port), time.Second*t.Timeout)

	// check if has error
	if err == nil {
		resp.IsOpen = true
		t.totalOpened += 1
	} else {
		if strings.Contains(err.Error(), "too many open files") {
			log.Printf("[ERROR] %v, retry in 3 second!", err)
			time.Sleep(time.Second * 3)
			t.scan(ip, port, resp)
			return
		} else {
			resp.IsOpen = false
		}
	}

	csvLine := t.lineCsv(ip, port.GetName(&t.service), port, resp.IsOpen)
	if t.Verbose {
		fmt.Printf("[Verbose] port '%v' on host '%v' is '%v'\n", port, ip, resp.IsOpen)
		if t.needReport {
			_, _ = t.report.WriteLine(csvLine)
		}
	} else {
		if resp.IsOpen {
			_, _ = t.report.WriteLine(csvLine)
		}
		t.printInfo()
	}

}

// lineCsv will prepare a CSV comma delimited line for writing reports
// target,port,portname,status
func (t *TCPScanner) lineCsv(target, portName string, port Port, status IsOpen) string {
	return fmt.Sprintf("%s,%d,%v,%s", target, port, portName, status)
}

// print info to the console
func (t *TCPScanner) printInfo() {
	fmt.Print("\033[s") // save the cursor position
	// fmt.Printf("\033[34m%v%% is done! (%v out of %v) \n", (100 * t.current / t.total), t.current, t.total)
	// fmt.Printf("\t\033[34mTotal opened port(s): %v \n", t.totalOpened)
	color.Cyan.Printf("%v%% is done! (%v out of %v total ports) \n", (100 * t.current / t.total), t.current, t.total)
	if t.totalOpened > 0 {
		color.Green.Printf("\tTotal opened port(s): %v \n", t.totalOpened)
	} else {
		color.Warn.Printf("\tTotal opened port(s): %v \n", t.totalOpened)
	}

	fmt.Print("\033[A") // move the cursor up
	fmt.Print("\033[A") // move the cursor up
}

func (t *TCPScanner) PrintTable(result []TCPScannerResponse) {

	// convert struct for better result
	var tbl [][]string
	for _, r := range result {
		if r.IsOpen == true || t.Verbose {
			tbl = append(tbl,
				[]string{
					r.IP, strconv.Itoa(int(r.Port)), r.PortName, r.IsOpen.String(),
				},
			)
		}
	}

	table := tablewriter.NewWriter(os.Stdout)
	table.SetHeader([]string{"IP", "PORT", "PORT NAME", "STATUS"})
	table.SetBorder(true)
	table.AppendBulk(tbl)
	table.Render()
}
