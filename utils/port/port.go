package port

import (
	"bufio"
	"fmt"
	"log"
	"os"
	"runtime"
	"strconv"
	"strings"
)

// Port struct
type Port struct {
	Proto string
	Name  string
}

// define service file path
var ServicesFile = "/etc/services"

type PortMap map[string]Port

type Service struct {
	portMaps PortMap
}

// initialize PortMaps
func (pm *Service) Init() error {
	if runtime.GOOS == "windows" {
		ServicesFile = os.Getenv("systemroot") + "\\System32\\drivers\\etc\\services"
	} else if runtime.GOOS == "darwin" || runtime.GOOS == "linux" {
		ServicesFile = "/etc/services"
	}

	file, err := os.Open(ServicesFile)
	if err != nil {
		return err
	}
	defer file.Close()

	port_map := make(PortMap)
	scanner := bufio.NewScanner(file)
	for scanner.Scan() {
		line := scanner.Text()
		if strings.HasPrefix(line, "#") {
			// ignore comments
			continue
		}
		line = strings.TrimSpace(line)
		split := strings.SplitN(line, "#", 2)

		fields := strings.Fields(split[0])

		if len(fields) < 2 {
			continue
		}
		name := fields[0]
		portproto := strings.SplitN(fields[1], "/", 2)
		port, err := strconv.ParseInt(portproto[0], 10, 32)
		if err != nil {
			log.Fatal(err)
		}
		proto := strings.ToLower(portproto[1])
		port_map[proto+"/"+fmt.Sprintf("%v", port)] = Port{
			Name:  name,
			Proto: proto,
		}
	}

	pm.portMaps = port_map
	return nil
}

// GetNameByNumber get port number & return the name(service) from services file
func (pm *Service) GetNameByNumber(port int, proto string) string {
	protocol := strings.ToLower(proto)
	n := "unknown"
	for i, v := range pm.portMaps {
		if fmt.Sprintf("%v", i) == (protocol + "/" + strconv.Itoa(port)) {
			n = v.Name
			break
		}
	}

	return n
}
