package target

import (
	"fmt"
	"regexp"
	"strings"
)

// TargetType - custom int type to define type of target
type TargetType int

// target type enum definition
const (
	TARGET_SINGLE_HOST TargetType = iota
	TARGET_SINGLE_IPv4
	TARGET_SINGLE_IPv6
	TAREGT_MULTIPLE_IP
	TARGET_CIDR_v4
	TARGET_CIDR_v6

	TARGET_RANGE
)

// String function to show what kind of target type we have
func (tt TargetType) String() string {
	return [...]string{
		"Single Host",
		"Single IPv4",
		"Single IPv6",
		"Multiple IPs",
		"IPv4/Mask (cidr)",
		"IPv6/Mask (cidr)",
		"IP Range",
	}[tt]
}

type Target string

// get type of target
func (t *Target) GetType() TargetType {

	if t.isIPv6() {
		return TARGET_SINGLE_IPv6
	}

	if t.isIPv4() {
		return TARGET_SINGLE_IPv4
	}

	if t.isCIDRv4() {
		return TARGET_CIDR_v4
	}

	if t.isCIDRv6() {
		return TARGET_CIDR_v6
	}

	if t.isMultiple() {
		return TAREGT_MULTIPLE_IP
	}

	if t.isRange() {
		return TARGET_RANGE
	}

	return TARGET_SINGLE_HOST
}

// validate if target is IPv4
func (t Target) isIPv4() bool {
	match, _ := regexp.MatchString("^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\\.){3}([1-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-4])$", fmt.Sprintf("%v", t))
	return match
}

// check if target is IPv6
func (t Target) isIPv6() bool {
	match, _ := regexp.MatchString("^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$",
		fmt.Sprintf("%v", t))
	return match
}

// check if target is IPv4
func (t Target) isCIDRv4() bool {
	match, _ := regexp.MatchString("^((?:\\d{1,3}.){3}\\d{1,3})\\/(\\d{1,2})$",
		fmt.Sprintf("%v", t))
	return match
}

// check if target is IPv6
func (t Target) isCIDRv6() bool {
	match, _ := regexp.MatchString("^s*((([0-9A-Fa-f]{1,4}:){7}([0-9A-Fa-f]{1,4}|:))|(([0-9A-Fa-f]{1,4}:){6}(:[0-9A-Fa-f]{1,4}|((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){5}(((:[0-9A-Fa-f]{1,4}){1,2})|:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3})|:))|(([0-9A-Fa-f]{1,4}:){4}(((:[0-9A-Fa-f]{1,4}){1,3})|((:[0-9A-Fa-f]{1,4})?:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){3}(((:[0-9A-Fa-f]{1,4}){1,4})|((:[0-9A-Fa-f]{1,4}){0,2}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){2}(((:[0-9A-Fa-f]{1,4}){1,5})|((:[0-9A-Fa-f]{1,4}){0,3}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(([0-9A-Fa-f]{1,4}:){1}(((:[0-9A-Fa-f]{1,4}){1,6})|((:[0-9A-Fa-f]{1,4}){0,4}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:))|(:(((:[0-9A-Fa-f]{1,4}){1,7})|((:[0-9A-Fa-f]{1,4}){0,5}:((25[0-5]|2[0-4]d|1dd|[1-9]?d)(.(25[0-5]|2[0-4]d|1dd|[1-9]?d)){3}))|:)))(%.+)?s*(\\/([0-9]|[1-9][0-9]|1[0-1][0-9]|12[0-8]))?$",
		fmt.Sprintf("%v", t))
	return match
}

// check if target is multiple
func (t Target) isMultiple() bool {
	h := fmt.Sprintf("%v", t)
	hosts := strings.Split(h, ",")

	if len(hosts) > 1 {
		for _, h := range hosts {
			th := Target(h)
			if !th.isCIDRv4() || !th.isCIDRv6() {
				return false
			}
		}
		return true
	}

	return false
}

// check if target is range
func (t Target) isRange() bool {
	h := fmt.Sprintf("%v", t)
	hosts := strings.Split(h, "-")

	t1 := Target(hosts[0])
	t2 := Target(hosts[1])

	if len(hosts) > 1 {
		if !t1.isCIDRv4() || !t1.isCIDRv6() {
			return false
		}
		if !t2.isCIDRv4() || !t2.isCIDRv6() {
			return false
		}

		return true
	}

	return false
}
