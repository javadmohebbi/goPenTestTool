package target

import (
	"fmt"
	"regexp"
	"strconv"
	"strings"
)

type TargetPorts string

// if get string of port & return portFrom & portTo
func (t TargetPorts) GetPorts() []int {

	ps := []int{}

	// check for single port
	if ch1, p1 := t.isSinglePort(); ch1 {
		return []int{p1}
	}

	// check for multiple ports
	if ch2, p2 := t.isMultiplePorts(); ch2 {
		return p2
	}

	// check for range
	if ch3, p3_1, p3_2 := t.isRange(); ch3 {
		var i1, i2 int
		if p3_1 == p3_2 {
			p3_2 += 1
		}
		if p3_1 > p3_2 {
			i1 = p3_1
			i2 = p3_2
		} else {
			i1 = p3_2
			i2 = p3_1
		}
		for j := i1; j < i2; j++ {
			ps = append(ps, j)
		}
		return ps
	}

	// return default if non of the above
	// were not successful

	for i := 0; i < 65535; i++ {
		ps = append(ps, i)
	}
	return ps
}

// check if it's single port
func (t TargetPorts) isSinglePort() (bool, int) {
	match, _ := regexp.MatchString("^([0-9]{1,4}|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-5])$",
		fmt.Sprintf("%v", t))
	p, _ := strconv.Atoi(string(t))
	return match, p
}

// check if it's multiple ports
func (t TargetPorts) isMultiplePorts() (bool, []int) {
	p := fmt.Sprintf("%v", t)
	ports := strings.Split(p, ",")

	ps := []int{}

	if len(ports) > 1 {
		for _, p := range ports {
			tp := TargetPorts(p)
			ch, i := tp.isSinglePort()
			if !ch {
				return false, []int{}
			} else {
				ps = append(ps, i)
			}
		}
		return true, ps
	}

	return false, []int{}
}

// check if taeget port is a range - returns false, from, to
func (t TargetPorts) isRange() (bool, int, int) {
	p := fmt.Sprintf("%v", t)
	ports := strings.Split(p, "-")

	p1 := TargetPorts(ports[0])
	p2 := TargetPorts(ports[1])

	if len(ports) > 1 {
		ch1, i1 := p1.isSinglePort()
		if !ch1 {
			return false, -1, -1
		}
		ch2, i2 := p2.isSinglePort()
		if !ch2 {
			return false, -1, -1
		}

		return true, i1, i2

	}

	return false, -1, -1
}
