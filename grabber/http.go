package grabber

import (
	"crypto/tls"
	"fmt"
	"net/http"
	"sync"

	"github.com/gookit/color"

	"github.com/cheggaaa/pb"

	"github.com/javadmohebbi/goPenTestTool/utils/port"
	"github.com/javadmohebbi/goPenTestTool/utils/reports"
	"golang.org/x/sync/semaphore"
)

type HTTPGrabber struct {
	GrabRequest

	lock *semaphore.Weighted
	wg   sync.WaitGroup

	service port.Service

	needReport bool
	report     *reports.Reports

	barInited bool
	bar       *pb.ProgressBar

	result map[string][]string
}

// Grab HTTP
func (g *HTTPGrabber) Grab() error {
	// print target to console
	fmt.Printf("Target=%s://%s:%v ==> %v\n", g.Type, g.Target.Host, g.Target.Port, g.Type)

	// set report path if needed
	if g.OutputPath == "" {
		g.needReport = false
	} else {
		// create new report
		// if has err, needReport will be false
		// and writing to a file will be ommited!
		rpt, err := reports.New(g.OutputPath)
		if err != nil {
			// if has error, we dont provide any RPT
			if g.Verbose {
				color.Red.Printf("[ERROR] Can not write to the requested RPT due to error '%v'", err.Error())
			}
			g.needReport = false
		} else {
			// if need RPT
			g.needReport = true
			g.report = rpt
		}
	}

	// default accept insecure
	http.DefaultTransport.(*http.Transport).TLSClientConfig = &tls.Config{InsecureSkipVerify: true}

	client := &http.Client{}
	req, _ := http.NewRequest("HEAD", fmt.Sprintf("%s://%s:%d/", g.Type, g.Target.Host, g.Target.Port), nil)

	// send http client request
	res, err := client.Do(req)

	// error check
	if err != nil {
		return err
	}

	g.result = res.Header
	return nil

}

// printTable will print output to the table
func (g *HTTPGrabber) Print() {
	fmt.Println("")
	for k, values := range g.result {
		color.Cyan.Printf("  %v: ", k)
		str := ""
		for _, v := range values {
			str += v + "\n"
		}
		color.White.Printf(str)
	}
	fmt.Println("")
}

// Write information to file
func (g *HTTPGrabber) WriteToFile() {
	str := fmt.Sprintf("Host: %v\nPort: %d\nType: %v\n", g.Target.Host, g.Target.Port, g.Type)
	fmt.Println("")
	for k, values := range g.result {
		str += fmt.Sprintf("%v: ", k)
		for _, v := range values {
			str += fmt.Sprintf("%v \n", v)
		}
	}
	if g.needReport {
		_, _ = g.report.WriteLine(str)
	}
}
