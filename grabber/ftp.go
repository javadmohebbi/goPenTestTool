package grabber

import (
	"fmt"
	"net"
	"sync"

	"github.com/gookit/color"

	"github.com/cheggaaa/pb"

	"github.com/javadmohebbi/goPenTestTool/utils/port"
	"github.com/javadmohebbi/goPenTestTool/utils/reports"
	"golang.org/x/sync/semaphore"
)

type FTPGrabber struct {
	GrabRequest

	lock *semaphore.Weighted
	wg   sync.WaitGroup

	service port.Service

	needReport bool
	report     *reports.Reports

	barInited bool
	bar       *pb.ProgressBar

	result map[string]string
}

// Grab HTTP
func (g *FTPGrabber) Grab() error {
	// print target to console
	fmt.Printf("Target=%s://%s:%v ==> %v\n", g.Type, g.Target.Host, g.Target.Port, g.Type)

	// set report path if needed
	if g.OutputPath == "" {
		g.needReport = false
	} else {
		// create new report
		// if has err, needReport will be false
		// and writing to a file will be ommited!
		rpt, err := reports.New(g.OutputPath)
		if err != nil {
			// if has error, we dont provide any RPT
			if g.Verbose {
				color.Red.Printf("[ERROR] Can not write to the requested RPT due to error '%v'", err.Error())
			}
			g.needReport = false
		} else {
			// if need RPT
			g.needReport = true
			g.report = rpt
		}
	}

	conn, err := net.Dial("tcp", fmt.Sprintf("%v:%d", g.Target.Host, g.Target.Port))
	if err != nil {
		return err
	}
	defer conn.Close()
	b := make([]byte, 1024)
	n, err := conn.Read(b)
	if err != nil {
		return err
	}
	g.result = make(map[string]string)
	g.result["FTPBanner"] = string(b[0:n])
	return nil

}

// printTable will print output to the table
func (g *FTPGrabber) Print() {
	for k, v := range g.result {
		color.Cyan.Printf("\n%v: \n\n", k)
		color.White.Printf("%v\n", v)
	}
}

// Write information to file
func (g *FTPGrabber) WriteToFile() {
	str := fmt.Sprintf("Host: %v\nPort: %d\nType: %v\n", g.Target.Host, g.Target.Port, g.Type)
	for k, v := range g.result {
		str += fmt.Sprintf("%v:\n%v\n", k, v)
	}
	if g.needReport {
		_, _ = g.report.WriteLine(str)
	}
}
